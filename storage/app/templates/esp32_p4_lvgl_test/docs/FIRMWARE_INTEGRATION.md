# Firmware Integration Guide

Complete guide for integrating SquareLine Studio UI with ESP32-P4 firmware backend logic

## Table of Contents
- [Overview](#overview)
- [Architecture](#architecture)
- [UI Event Handlers](#ui-event-handlers)
- [Display Updates](#display-updates)
- [State Management](#state-management)
- [Network Integration](#network-integration)
- [NFC Integration](#nfc-integration)
- [Best Practices](#best-practices)

## Overview

This guide explains how to connect the SquareLine Studio UI (visual interface) with the ESP32 firmware backend (business logic, NFC, network, etc.).

### Key Concepts

1. **UI Events** → Trigger firmware actions
2. **Firmware State** → Updates UI display
3. **Async Operations** → Network calls, NFC reads
4. **Thread Safety** → LVGL runs in its own task

## Architecture

### Component Layers

```
┌─────────────────────────────────────┐
│   SquareLine Studio UI (LVGL)       │  ← User interactions
├─────────────────────────────────────┤
│   ui_events.c (Event Handlers)      │  ← Bridge layer (YOU EDIT)
├─────────────────────────────────────┤
│   Firmware Logic Layer              │  ← Business logic
│   - API Client                       │
│   - NFC Reader                       │
│   - Network Manager                  │
│   - Configuration                    │
├─────────────────────────────────────┤
│   ESP-IDF / FreeRTOS                │  ← Operating system
└─────────────────────────────────────┘
```

### File Structure

```
main/
├── main.c                    # Application entry point
├── ui_manager.c/h            # UI management and updates
├── api_client.c/h            # API communication
├── nfc_reader.c/h            # NFC card reading
├── network_manager.c/h       # WiFi/Ethernet management
└── features.h                # Feature flags

ui/
├── ui_events.c               # ← YOU IMPLEMENT EVENT HANDLERS HERE
├── ui_events.h
├── ui.c/h                    # ← Generated by SquareLine (don't edit)
└── ui_screen_*.c/h           # ← Generated by SquareLine (don't edit)
```

## UI Event Handlers

### Understanding ui_events.c

After SquareLine exports, `ui_events.c` contains **stub functions** for each event you defined in the designer. You must implement these functions.

#### Example: Generated Stub

```c
// This file was generated by SquareLine Studio
#include "ui.h"

void ui_event_button_wifi_setup(lv_event_t * e)
{
    // Your code here
}
```

#### Implementation Pattern

```c
// ui_events.c
#include "ui.h"
#include "ui_manager.h"      // For UI update functions
#include "network_manager.h" // For WiFi functions

void ui_event_button_wifi_setup(lv_event_t * e)
{
    lv_event_code_t code = lv_event_get_code(e);

    if(code == LV_EVENT_CLICKED) {
        ESP_LOGI("UI", "WiFi setup button clicked");

        // Navigate to WiFi setup screen
        lv_scr_load(ui_screen_wifisetup);
    }
}
```

### Common Event Types

```c
LV_EVENT_CLICKED        // Button pressed and released
LV_EVENT_VALUE_CHANGED  // Dropdown, slider, switch changed
LV_EVENT_READY          // Keyboard input completed
LV_EVENT_CANCEL         // User cancelled operation
LV_EVENT_SCREEN_LOADED  // Screen became visible
```

### Implementing Form Submission

Example: WiFi configuration form

```c
void ui_event_button_wifi_connect(lv_event_t * e)
{
    lv_event_code_t code = lv_event_get_code(e);

    if(code == LV_EVENT_CLICKED) {
        // Get text from input fields
        const char *ssid = lv_textarea_get_text(ui_wifi_ssid_input);
        const char *password = lv_textarea_get_text(ui_wifi_password_input);

        if(strlen(ssid) == 0) {
            // Show error message
            lv_label_set_text(ui_wifi_status_label, "SSID required");
            return;
        }

        // Show connecting status
        lv_label_set_text(ui_wifi_status_label, "Connecting...");

        // Initiate WiFi connection (non-blocking)
        wifi_config_t wifi_config = {
            .sta = {
                .ssid = "",
                .password = "",
            },
        };
        strncpy((char*)wifi_config.sta.ssid, ssid, sizeof(wifi_config.sta.ssid));
        strncpy((char*)wifi_config.sta.password, password, sizeof(wifi_config.sta.password));

        // Call network manager to connect
        esp_err_t ret = network_manager_connect_wifi(&wifi_config);

        if(ret != ESP_OK) {
            lv_label_set_text(ui_wifi_status_label, "Connection failed!");
        }
        // Success status will be updated by network event callback
    }
}
```

### Implementing Admin Password Validation

```c
void ui_event_button_admin_login(lv_event_t * e)
{
    lv_event_code_t code = lv_event_get_code(e);

    if(code == LV_EVENT_CLICKED) {
        const char *password = lv_textarea_get_text(ui_admin_password_input);

        // Validate password
        if(strcmp(password, DEFAULT_ADMIN_PASSWORD) == 0) {
            ESP_LOGI("UI", "Admin authenticated");

            // Clear password field
            lv_textarea_set_text(ui_admin_password_input, "");

            // Navigate to setup menu
            lv_scr_load(ui_screen_setupconfigurations);
        } else {
            ESP_LOGW("UI", "Invalid admin password");

            // Show error
            lv_label_set_text(ui_admin_error_label, "Invalid password!");

            // Clear password field
            lv_textarea_set_text(ui_admin_password_input, "");
        }
    }
}
```

## Display Updates

### Thread Safety with LVGL

⚠️ **CRITICAL**: LVGL is **not thread-safe**. All LVGL function calls must be protected with a mutex.

#### Safe Update Pattern

```c
// From any task/thread
void update_status_message(const char *message)
{
    // Lock LVGL mutex
    if(bsp_display_lock(0)) {
        // Safe to call LVGL functions here
        lv_label_set_text(ui_status_label, message);

        // Unlock mutex
        bsp_display_unlock();
    }
}
```

#### Using UI Manager (Recommended)

Create a `ui_manager.c` to centralize UI updates:

```c
// ui_manager.h
void ui_manager_show_message(const char *message, bool is_success);
void ui_manager_update_time(const char *time_str);
void ui_manager_update_employee_info(const char *name, float hours);

// ui_manager.c
#include "ui_manager.h"
#include "ui.h"
#include "bsp/display.h"

void ui_manager_show_message(const char *message, bool is_success)
{
    if(bsp_display_lock(0)) {
        lv_label_set_text(ui_message_label, message);

        // Set color based on success/error
        if(is_success) {
            lv_obj_set_style_text_color(ui_message_label,
                lv_color_hex(0x28A745), LV_PART_MAIN);  // Green
        } else {
            lv_obj_set_style_text_color(ui_message_label,
                lv_color_hex(0xDC3545), LV_PART_MAIN);  // Red
        }

        bsp_display_unlock();
    }
}

void ui_manager_update_time(const char *time_str)
{
    if(bsp_display_lock(0)) {
        lv_label_set_text(ui_time_label, time_str);
        bsp_display_unlock();
    }
}
```

### Updating from Network Callbacks

When API responses arrive, update UI from callback:

```c
// api_client.c - callback from HTTP response
static void on_punch_response(api_response_t *response)
{
    if(response->success) {
        // Extract employee name from JSON
        const char *employee_name = json_get_string(response->data, "employee_name");
        const char *event_time = json_get_string(response->data, "event_time");

        // Build message
        char message[128];
        snprintf(message, sizeof(message),
            "Hello %s!\nTime: %s", employee_name, event_time);

        // Update UI (thread-safe)
        ui_manager_show_message(message, true);
    } else {
        ui_manager_show_message("Card not recognized", false);
    }
}
```

## State Management

### Application State Structure

```c
// app_state.h
typedef struct {
    bool wifi_connected;
    bool ethernet_connected;
    bool nfc_initialized;
    bool api_authenticated;
    char device_id[32];
    char api_token[128];
    char current_employee_name[64];
} app_state_t;

extern app_state_t g_app_state;
```

### Initializing State

```c
// main.c
app_state_t g_app_state = {
    .wifi_connected = false,
    .ethernet_connected = false,
    .nfc_initialized = false,
    .api_authenticated = false,
};
```

### Using State in UI Events

```c
void ui_event_button_device_info(lv_event_t * e)
{
    if(lv_event_get_code(e) == LV_EVENT_CLICKED) {
        if(bsp_display_lock(0)) {
            // Update device info labels from state
            lv_label_set_text_fmt(ui_device_id_label, "ID: %s", g_app_state.device_id);

            lv_label_set_text(ui_wifi_status_label,
                g_app_state.wifi_connected ? "Connected" : "Disconnected");

            // Navigate to device info screen
            lv_scr_load(ui_screen_deviceinformation);

            bsp_display_unlock();
        }
    }
}
```

## Network Integration

### WiFi Setup Flow

```c
// ui_events.c - User submits WiFi credentials
void ui_event_wifi_connect_clicked(lv_event_t * e)
{
    // Get credentials from UI
    const char *ssid = lv_textarea_get_text(ui_wifi_ssid_input);
    const char *password = lv_textarea_get_text(ui_wifi_password_input);

    // Show connecting status
    ui_manager_show_message("Connecting to WiFi...", true);

    // Start connection (async)
    network_manager_connect_wifi_async(ssid, password, on_wifi_connected);
}

// network_manager.c - WiFi event callback
static void on_wifi_connected(bool success)
{
    g_app_state.wifi_connected = success;

    if(success) {
        ESP_LOGI(TAG, "WiFi connected, obtaining IP...");

        // Update UI
        ui_manager_show_message("WiFi Connected!", true);

        // Start API authentication
        api_client_authenticate();
    } else {
        ui_manager_show_message("WiFi connection failed", false);
    }
}
```

### API Authentication Flow

```c
// After WiFi connects, authenticate with backend
void api_client_authenticate(void)
{
    // Get MAC address for device identification
    uint8_t mac[6];
    esp_read_mac(mac, ESP_MAC_WIFI_STA);

    char mac_str[18];
    snprintf(mac_str, sizeof(mac_str),
        "%02X:%02X:%02X:%02X:%02X:%02X",
        mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);

    // Build JSON request
    cJSON *json = cJSON_CreateObject();
    cJSON_AddStringToObject(json, "mac_address", mac_str);
    cJSON_AddStringToObject(json, "device_name", DEVICE_NAME);
    cJSON_AddStringToObject(json, "firmware_version", FIRMWARE_VERSION);

    // Send POST request to /api/v1/timeclock/auth
    http_client_post("/api/v1/timeclock/auth", json, on_auth_response);
}

static void on_auth_response(http_response_t *response)
{
    if(response->status_code == 200) {
        cJSON *data = cJSON_Parse(response->body);

        // Extract token
        const char *token = cJSON_GetStringValue(
            cJSON_GetObjectItem(data, "api_token"));

        // Save to app state
        strncpy(g_app_state.api_token, token, sizeof(g_app_state.api_token));
        g_app_state.api_authenticated = true;

        ESP_LOGI(TAG, "API authenticated successfully");

        // Update UI
        ui_manager_show_message("System Ready", true);

        cJSON_Delete(data);
    } else {
        ESP_LOGE(TAG, "Authentication failed: %d", response->status_code);
        ui_manager_show_message("API auth failed", false);
    }
}
```

## NFC Integration

### NFC Card Read Flow

```c
// main.c - NFC reader task
static void nfc_reader_task(void *pvParameters)
{
    uint8_t card_uid[10];
    uint8_t uid_len;

    while(1) {
        // Poll for card (blocking, 500ms timeout)
        if(nfc_reader_poll(nfc_reader, card_uid, &uid_len, 500) == ESP_OK) {
            // Card detected!
            char uid_str[32];
            bytes_to_hex_string(card_uid, uid_len, uid_str, sizeof(uid_str));

            ESP_LOGI(TAG, "Card detected: %s", uid_str);

            // Check for duplicate (debounce)
            uint64_t now = esp_timer_get_time() / 1000;
            if(strcmp(uid_str, last_card_uid) == 0 &&
               (now - last_card_time) < 3000) {
                // Same card within 3 seconds - ignore
                continue;
            }

            // Update last card info
            strncpy(last_card_uid, uid_str, sizeof(last_card_uid));
            last_card_time = now;

            // Show feedback on UI
            ui_manager_show_message("Card detected...", true);

            // Send punch to API
            api_client_send_punch("nfc", uid_str);
        }

        vTaskDelay(pdMS_TO_TICKS(100));
    }
}

// api_client.c - Send punch to server
void api_client_send_punch(const char *credential_kind, const char *credential_value)
{
    if(!g_app_state.api_authenticated) {
        ESP_LOGW(TAG, "Not authenticated, cannot send punch");
        ui_manager_show_message("System not ready", false);
        return;
    }

    // Build punch request
    cJSON *json = cJSON_CreateObject();
    cJSON_AddStringToObject(json, "device_id", g_app_state.device_id);
    cJSON_AddStringToObject(json, "credential_kind", credential_kind);
    cJSON_AddStringToObject(json, "credential_value", credential_value);

    // Get current time
    time_t now;
    time(&now);
    struct tm timeinfo;
    localtime_r(&now, &timeinfo);
    char time_str[32];
    strftime(time_str, sizeof(time_str), "%Y-%m-%d %H:%M:%S", &timeinfo);
    cJSON_AddStringToObject(json, "event_time", time_str);

    // Send with Authorization header
    http_client_post_with_auth("/api/v1/timeclock/punch",
        json, g_app_state.api_token, on_punch_response);
}

static void on_punch_response(http_response_t *response)
{
    cJSON *data = cJSON_Parse(response->body);

    if(response->status_code == 200) {
        // Success - show employee greeting
        const char *display_msg = cJSON_GetStringValue(
            cJSON_GetObjectItem(data, "display_message"));

        ui_manager_show_message(display_msg, true);

        // Auto-return to main screen after 5 seconds
        // (implement timer in ui_manager)
    } else {
        // Error - show error message
        const char *display_msg = cJSON_GetStringValue(
            cJSON_GetObjectItem(data, "display_message"));

        ui_manager_show_message(
            display_msg ? display_msg : "Error recording time",
            false);
    }

    cJSON_Delete(data);
}
```

## Best Practices

### 1. Separate Concerns

```
UI Events → Call manager functions → Manager updates backend → Callback updates UI
```

Don't mix UI code with business logic.

### 2. Always Use Thread-Safe UI Updates

```c
// ✅ GOOD
if(bsp_display_lock(0)) {
    lv_label_set_text(label, "Hello");
    bsp_display_unlock();
}

// ❌ BAD
lv_label_set_text(label, "Hello");  // From another task = CRASH!
```

### 3. Validate User Input

```c
// Always check for empty/invalid input
if(strlen(ssid) == 0 || strlen(ssid) > 32) {
    ui_manager_show_message("Invalid SSID", false);
    return;
}
```

### 4. Provide User Feedback

```c
// Show status at each step
ui_manager_show_message("Connecting...", true);
// ... wait for result ...
ui_manager_show_message("Connected!", true);
```

### 5. Handle Errors Gracefully

```c
if(ret != ESP_OK) {
    ESP_LOGE(TAG, "Operation failed: %s", esp_err_to_name(ret));
    ui_manager_show_message("Operation failed. Try again.", false);
    return;
}
```

### 6. Use Timeouts

```c
// Auto-return to main screen after message
void ui_manager_show_message_with_timeout(const char *msg, bool success, uint32_t timeout_ms)
{
    show_message(msg, success);

    // Create timer to return to main screen
    lv_timer_t *timer = lv_timer_create(return_to_main_screen_cb, timeout_ms, NULL);
    lv_timer_set_repeat_count(timer, 1);
}
```

### 7. Log Everything

```c
ESP_LOGI(TAG, "User clicked WiFi setup");
ESP_LOGI(TAG, "Connecting to SSID: %s", ssid);
ESP_LOGI(TAG, "WiFi connected, IP: %s", ip_str);
```

Logs are essential for debugging!

## Testing

### Simulator Testing

1. Test all UI interactions in SquareLine Simulator
2. Verify navigation flows
3. Check text/layout for all screens

### Hardware Testing

1. **Unit test each component**:
   ```bash
   # Test WiFi connection
   # Test NFC reading
   # Test API authentication
   ```

2. **Integration test full flow**:
   - Connect to WiFi
   - Authenticate with API
   - Read NFC card
   - Verify punch recorded
   - Check display shows correct info

3. **Error scenario testing**:
   - Wrong WiFi password
   - Network disconnect during operation
   - API server down
   - Unrecognized NFC card
   - Invalid admin password

## Example: Complete Feature Implementation

### Feature: Display Current Time

**1. Add label to mainscreen in SquareLine**:
- Name: `ui_time_label`
- Position: Top center
- Font: Large (32pt)
- Text: "00:00:00"

**2. Export UI from SquareLine**

**3. Create time update task**:

```c
// main.c
static void time_update_task(void *pvParameters)
{
    char time_buffer[32];

    while(1) {
        // Get current time
        time_t now;
        struct tm timeinfo;
        time(&now);
        localtime_r(&now, &timeinfo);

        // Format time string
        strftime(time_buffer, sizeof(time_buffer), "%I:%M:%S %p", &timeinfo);

        // Update UI (thread-safe)
        ui_manager_update_time(time_buffer);

        // Update every second
        vTaskDelay(pdMS_TO_TICKS(1000));
    }
}

void app_main(void)
{
    // ... initialization ...

    // Start time update task
    xTaskCreate(time_update_task, "time_update", 4096, NULL, 5, NULL);
}
```

**4. Implement UI manager function**:

```c
// ui_manager.c
void ui_manager_update_time(const char *time_str)
{
    if(bsp_display_lock(0)) {
        lv_label_set_text(ui_time_label, time_str);
        bsp_display_unlock();
    }
}
```

**Done!** Time updates every second on the display.

## Next Steps

- Review [API_INTEGRATION.md](API_INTEGRATION.md) for API details
- Review [DEPLOYMENT_GUIDE.md](DEPLOYMENT_GUIDE.md) for building and flashing
- See [CUSTOMIZATION_GUIDE.md](CUSTOMIZATION_GUIDE.md) for adding features

## Resources

- ESP-IDF Programming Guide: https://docs.espressif.com/projects/esp-idf/
- LVGL Documentation: https://docs.lvgl.io/
- FreeRTOS Guide: https://www.freertos.org/

---

Last Updated: 2026-01-26
Firmware Version: Compatible with ESP-IDF v5.5.1
